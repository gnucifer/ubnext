<?php


/**
 * Implements hook_search_api_autocomplete_suggester_info()
 */
function ubn_search_api_solr_search_api_autocomplete_suggester_info() {
  $suggesters['ubn_solr_server'] = array(
    'label' => t('Retrieve from UBN Solr server'),
    'description' => t('For an UBN Solr server, ask the server for autocomplete suggestions using the preconfigured "autocomplete" field found in the custom UBN schema.xml.'),
    'class' => 'UBNSearchApiAutocompleteServerSuggester',
  );
  return $suggesters;
}

/**
 * Implements hook_module_implements_alter().
 */
function ubn_search_api_solr_module_implements_alter(&$implementations, $hook) {
  // We want to come after search_api_solr_et_documents_alter
  // since depending on fields set by this module
  if ($hook == 'search_api_solr_documents_alter') {
    $implementation = $implementations['ubn_search_api_solr'];
    unset($implementations['ubn_search_api_solr']);
    $implementations['ubn_search_api_solr'] = $implementation;
  }
}



/**
 * Implements hook_search_api_solr_documents_alter().
 */
function ubn_search_api_solr_search_api_solr_documents_alter(&$documents, $index, $items) {
  // Run this only for multilingual indexes provided by search_api_et module.
  $server = $index->server();
  // Or use supports index when implemented

  //Load all autocomplete searches and check if using this index?
  if ($server->module === 'ubn_search') {
    $index_id = $index->machine_name;
    $autocomplete_searches = search_api_autocomplete_search_load_multiple(FALSE, array('index_id' => $index_id));
    if(!empty($autocomplete_searches)) {
      $autocomplete_search = reset($autocomplete_searches);
      //$autocomplete_fields = 
      $suggester = $autocomplete_search->getSuggester();
      //Check suggester type?
      $config = $suggester->getConfiguration();
      $fields = $config['fields'];

      //Get solr field names
      $solr_field_names = $server->getFieldNames($index);
      $autocomplete_solr_fields = array();
      foreach($fields as $field) {
        $autocomplete_solr_field_names[] = $solr_field_names[$field];
      }

      $entity_type = str_replace('search_api_et_', '', $index->item_type);
      foreach ($documents as $delta => $document) {
        // Get the current document language.
        $document_language_field = $document->getField('ss_search_api_language');
        $document_language = $document_language_field['value'];

        $autocomplete_fields = array_intersect($autocomplete_solr_field_names, $document->getFieldNames());
        foreach ($autocomplete_fields as $solr_field_name) {
          if (strpos($solr_field_name, '_') !== FALSE) {
            list($solr_prefix, $field_name) = explode('_', $solr_field_name, 2);
            // For translatable fields, store the value in relevant multilingual
            // solr field instead of the default one.
            //if (search_api_et_solr_field_is_translatable($field_name, $entity_type, $index)) {
              $old_solr_field = $document->getField($solr_field_name);
              //Replace whatever solr prefix with simple string
              //this seems a bit hackish, but should work
              //and avoids unnecessary processing by solr
              //(since autocomplete fields are just sources for copyField
              //directive and not used for anything else)
              $solr_prefix = str_replace('t', 's', $solr_prefix);
              $multilingual_autocomplete_solr_field_name = implode('_', array($solr_prefix, 'autocomplete', $index_id, $document_language, $field_name));
              //TODO: how does boost work here?
              $document->setField($multilingual_autocomplete_solr_field_name, $old_solr_field['value'], $old_solr_field['boost']);
            //}
          }
        }
      }
    }
  }
}


/*
function ubn_search_api_solr_entity_property_info_alter(&$info) {
}
*/

/**
 * Implements hook_search_api_alter_callback_info().
 */
/*
function ubn_search_api_solr_search_api_alter_callback_info() {
  $callbacks['search_api_solr_alter_add_autocomplete_field'] = array(
    'name' => t('UBN (pseudo) autocomplete field'),
    'description' => t('A hack to make search api recognize the aggregated "autocomplete" field in the UBN schema.xml'),
    'class' => 'UBNSearchApiSolrAlterAddAutocompleteField',
  );
  return $callbacks;
}
*/

/** TODO Implements etc **/
/*
function ubn_search_api_solr_search_api_data_type_info() {
  return array(
    // You can use any identifier you want here, but it makes sense to use the
    // field type name from schema.xml.
    'spell' => array(
      // Stock hook_search_api_data_type_info() info:
      'name' => t('Fulltext (w/ partial matching)'),
      'fallback' => 'text',
      // Dynamic field with name="te_*".
      'prefix' => '',
      // Fulltext types should always be multi-valued.
      'always multiValued' => FALSE,
    ),
  );
}
*/

// hook_search_api_service_info_alter
function ubn_search_api_solr_search_api_service_info_alter(&$info) {
  $info['search_api_solr_service']['name'] = t('UBN Solr Service');
  $info['search_api_solr_service']['class'] = 'UBNSearchAPISolrService';
  $info['search_api_solr_service']['module'] = 'ubn_search_api_solr';
}

// TODO: Better way of overriding this
function ubn_search_api_solr_entity_load($entities, $type) {
  if($type === 'search_api_index') {
    /*
    foreach($entities as $entity) {
      $entity->options['fields']['autocomplete'] = array(
        'type' => 'text',
      );
    }
    */
  }
  else if($type === 'search_api_autocomplete_search') {
    foreach($entities as $entity) {
      $entity->suggester_id = 'ubn_solr_server';
      //$entity->options['suggester_configuration']['fields'] = array('autocomplete');
    }
  }
}
